
schema {
  query: RootQuery
  mutation: TokenMutation
  subscription: Subscription
}

"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int! = 0

  """Streamed when true."""
  if: Boolean
) on FIELD

input AddTokenInput {
  token: TokenInput!
}

type AddTokenPayload {
  tokenPayload: TokenPayload
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

"""
The node interface is implemented by entities that have a global unique identifier.
"""
interface Node {
  id: ID!
}

type RootQuery {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node

  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  tokens(where: TokenFilterInput): [Token!]!
}

type Subscription {
  tokenChange: TokenChangeEvent!
}

type Token implements Node {
  id: ID!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

type TokenChangeEvent {
  id: Int!
  type: TokenChangeEventType!
  payload: TokenPayload
}

enum TokenChangeEventType {
  ADDED
  UPDATED
  DELETED
}

input TokenFilterInput {
  and: [TokenFilterInput!]
  or: [TokenFilterInput!]
  id: ComparableInt32OperationFilterInput
  x: ComparableInt32OperationFilterInput
  y: ComparableInt32OperationFilterInput
  width: ComparableInt32OperationFilterInput
  height: ComparableInt32OperationFilterInput
}

input TokenInput {
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

type TokenMutation {
  updateToken(input: UpdateTokenInput!): UpdateTokenPayload!
  addToken(input: AddTokenInput!): AddTokenPayload!
}

type TokenPayload {
  id: Int!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

input UpdateTokenInput {
  id: ID!
  token: TokenInput!
}

type UpdateTokenPayload {
  tokenPayload: TokenPayload
}

