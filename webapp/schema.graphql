schema {
  query: RootQuery
  mutation: Mutation
  subscription: Subscription
}

"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int! = 0

  """Streamed when true."""
  if: Boolean
) on FIELD

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

enum Ability5E {
  STRENGTH
  DEXTERITY
  CONSTITUTION
  INTELLIGENCE
  WISDOM
  CHARISMA
}

enum Alignment5E {
  ANY
  UNALIGNED
  CHAOTIC_GOOD
  NEUTRAL_GOOD
  LAWFUL_GOOD
  CHAOTIC_NEUTRAL
  TRUE_NEUTRAL
  LAWFUL_NEUTRAL
  CHAOTIC_EVIL
  NEUTRAL_EVIL
  LAWFUL_EVIL
}

type AppFile {
  id: ID!
  ownerId: ID!
}

input AppFileInput {
  id: ID!
  ownerId: ID!
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

type ArmorClassOption5E {
  armorClass: Int!
  description: String!
}

input ArmorClassOption5EInput {
  armorClass: Int!
  description: String!
}

type Campaign implements Node {
  id: ID!
  name: String!
  description: String!
  selectedSceneId: ID
  participants: [CampaignEnrollment!]!
  selectedScene(sceneId: ID): Scene
  scenes: [Scene!]!
  isDungeonMaster: Boolean!
  messages(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: MessageFilterInput
  ): MessagesConnection
}

input CampaignAddInput {
  name: String!
  description: String!
  playerName: String!
}

type CampaignAddPayload {
  campaign: Campaign
}

type CampaignEnrollment {
  userId: ID!
  playerName: String!
  roll: CampaignRoll!
}

input CampaignEnrollmentFilterInput {
  and: [CampaignEnrollmentFilterInput!]
  or: [CampaignEnrollmentFilterInput!]
  userId: IdOperationFilterInput
  playerName: StringOperationFilterInput
  roll: CampaignRollOperationFilterInput
}

input CampaignFilterInput {
  and: [CampaignFilterInput!]
  or: [CampaignFilterInput!]
  id: IdOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  selectedSceneId: IdOperationFilterInput
  participants: ListFilterInputTypeOfCampaignEnrollmentFilterInput
}

enum CampaignRoll {
  DUNGEON_MASTER
  PLAYER
}

input CampaignRollOperationFilterInput {
  eq: CampaignRoll
  neq: CampaignRoll
  in: [CampaignRoll!]
  nin: [CampaignRoll!]
}

enum ChangeMessageType {
  ADD
  UPDATE
  DELETE
}

input ComparableDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableGuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID!]
  nin: [UUID!]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input ComparableNullableOfGuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

enum DamageType5E {
  BLUDGEONING
  PIERCING
  SLASHING
  ACID
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input EnrollmentAddInput {
  code: String!
  playerName: String!
}

type EnrollmentAddPayload {
  campaignEnrollment: CampaignEnrollment
}

input EnrollmentCodeInput {
  campaingId: ID!
}

type EnrollmentCodePayload {
  string: String
}

"""A connection to a list of items."""
type EntriesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [EntriesEdge!]

  """A flattened list of the nodes."""
  nodes: [Entry!]
  totalCount: Int!
}

"""An edge in a connection."""
type EntriesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Entry!
}

union Entry = Npc5E

input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}

input IEntryFilterInput {
  and: [IEntryFilterInput!]
  or: [IEntryFilterInput!]
  id: ComparableGuidOperationFilterInput
  sourceId: ComparableGuidOperationFilterInput
  ownerId: ComparableGuidOperationFilterInput
}

type ImageContent {
  file: AppFile
  width: Float!
  height: Float!
  resizable: Boolean!
}

type KeyValuePairOfAbility5EAndInt32 {
  key: Ability5E!
  value: Int!
}

input KeyValuePairOfAbility5EAndInt32Input {
  key: Ability5E!
  value: Int!
}

type KeyValuePairOfSkillAndInt32 {
  key: Skill!
  value: Int!
}

input KeyValuePairOfSkillAndInt32Input {
  key: Skill!
  value: Int!
}

type Language5E {
  name: String!
}

input Language5EInput {
  name: String!
}

input ListFilterInputTypeOfCampaignEnrollmentFilterInput {
  all: CampaignEnrollmentFilterInput
  none: CampaignEnrollmentFilterInput
  some: CampaignEnrollmentFilterInput
  any: Boolean
}

input MapEntitiesImageAddInput {
  sceneId: ID!
  entities: [MapEntityImageAddInput!]!
}

input MapEntitiesNpc5EAddInput {
  sceneId: ID!
  entities: [MapEntityNpc5EAddInput!]!
}

input MapEntitiesPositionUpdateInput {
  sceneId: ID!
  entities: [MapEntityPositionUpdateInput!]!
}

type MapEntity implements Node {
  id: ID!
  name: String!
  x: Float!
  y: Float!
  width: Float!
  height: Float!
  resizable: Boolean!
  content: MapEntityContent!
}

type MapEntityChangeMessage {
  type: ChangeMessageType!
  userId: UUID!
  payload: [MapEntity!]!
}

union MapEntityContent = ImageContent | Npc5EContent

input MapEntityDeleteInput {
  sceneId: ID!
  deleted: [ID!]!
}

type MapEntityDeletePayload {
  id: ID!
}

input MapEntityImageAddInput {
  name: String!
  x: Int!
  y: Int!
  uploadId: UUID!
  width: Int!
  height: Int!
}

type MapEntityImageAddPayload {
  mapEntity: [MapEntity!]
}

input MapEntityNpc5EAddInput {
  npcId: ID!
  name: String!
  x: Int!
  y: Int!
  ac: Int!
  maxHp: Int!
  size: Size5E!
}

type MapEntityNpc5EAddPayload {
  mapEntity: [MapEntity!]
}

input MapEntityPositionUpdateInput {
  id: ID!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

type MapEntityPositionUpdatePayload {
  mapEntity: [MapEntity!]
}

type Message implements Node {
  id: ID!
  userId: UUID!
  content: MessageContent!
  campaignId: UUID!
  createdAt: DateTime!
  sourceName: String!
  sourceId: UUID
}

union MessageContent = RollMessageContent | TextMessageContent

input MessageContentFilterInput {
  and: [MessageContentFilterInput!]
  or: [MessageContentFilterInput!]
}

input MessageFilterInput {
  and: [MessageFilterInput!]
  or: [MessageFilterInput!]
  id: ComparableGuidOperationFilterInput
  userId: ComparableGuidOperationFilterInput
  content: MessageContentFilterInput
  campaignId: ComparableGuidOperationFilterInput
  createdAt: ComparableDateTimeOperationFilterInput
  sourceName: StringOperationFilterInput
  sourceId: ComparableNullableOfGuidOperationFilterInput
}

"""A connection to a list of items."""
type MessagesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessagesEdge!]

  """A flattened list of the nodes."""
  nodes: [Message!]
}

"""An edge in a connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Message!
}

type Mutation {
  campaignAdd(input: CampaignAddInput!): CampaignAddPayload!
  sceneAdd(input: SceneAddInput!): SceneAddPayload!
  sceneDelete(input: SceneDeleteInput!): SceneDeletePayload!
  sceneUpdate(input: SceneUpdateInput!): SceneUpdatePayload!
  userAdd(input: UserAddInput!): UserAddPayload!
  enrollmentCode(input: EnrollmentCodeInput!): EnrollmentCodePayload!
  enrollmentAdd(input: EnrollmentAddInput!): EnrollmentAddPayload!
  textMessageAdd(input: TextMessagesAddInput!): TextMessageAddPayload!
  rollMessageAdd(input: RollMessagesAddInput!): RollMessageAddPayload!
  mapEntityPositionUpdate(input: MapEntitiesPositionUpdateInput!): MapEntityPositionUpdatePayload!
  mapEntityDelete(input: MapEntityDeleteInput!): [MapEntityDeletePayload!]!
  npcs5EAdd(input: Npcs5EAddInput!): Npcs5EAddPayload!
  mapEntityNpc5EAdd(input: MapEntitiesNpc5EAddInput!): MapEntityNpc5EAddPayload!
  mapEntityImageAdd(input: MapEntitiesImageAddInput!): MapEntityImageAddPayload!
}

"""
The node interface is implemented by entities that have a global unique identifier.
"""
interface Node {
  id: ID!
}

type Npc5E {
  id: ID!
  sourceId: UUID!
  ownerId: UUID!
  avatar: AppFile!
  page: Int!
  type: NpcType5E!
  hitPointsFormula: String!
  hitPointsAverage: Int!
  armorClasses: [ArmorClassOption5E!]!
  challangeRating: Float!
  alignments: [Alignment5E!]!
  sizes: [Size5E!]!
  savingThrows: [KeyValuePairOfAbility5EAndInt32!]!
  skills: [KeyValuePairOfSkillAndInt32!]!
  name: String!
  languages: [Language5E!]!
  senses: [Sense5E!]!
  passivePerception: Int!
  resistances: [Resistance5E!]!
  speeds: Speed5E!
  strength: Int!
  dexterity: Int!
  constitution: Int!
  intelligence: Int!
  wisdom: Int!
  charisma: Int!
}

type Npc5EContent {
  editorSize: Float!
  npcId: ID!
  size: Size5E!
  maximumHp: Int!
  currentHp: Int!
  temporaryHp: Int!
  ac: Int!
  width: Float!
  height: Float!
  resizable: Boolean!
}

input Npc5EInput {
  id: ID!
  sourceId: UUID!
  ownerId: UUID!
  avatar: AppFileInput!
  page: Int!
  type: NpcType5EInput!
  hitPointsFormula: String!
  hitPointsAverage: Int!
  armorClasses: [ArmorClassOption5EInput!]!
  challangeRating: Float!
  alignments: [Alignment5E!]!
  sizes: [Size5E!]!
  savingThrows: [KeyValuePairOfAbility5EAndInt32Input!]!
  skills: [KeyValuePairOfSkillAndInt32Input!]!
  name: String!
  languages: [Language5EInput!]!
  senses: [Sense5EInput!]!
  passivePerception: Int!
  resistances: [Resistance5EInput!]!
  speeds: Speed5EInput!
  strength: Int!
  dexterity: Int!
  constitution: Int!
  intelligence: Int!
  wisdom: Int!
  charisma: Int!
}

input Npcs5EAddInput {
  sourceId: ID!
  characters: [Npc5EInput!]!
}

type Npcs5EAddPayload {
  npc5E: [Npc5E!]
}

type NpcType5E {
  label: String!
  tags: [String!]
}

input NpcType5EInput {
  label: String!
  tags: [String!]
}

"""Information about pagination in a connection."""
type PageInfo {
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Resistance5E {
  types: [DamageType5E!]!
  condition: String
}

input Resistance5EInput {
  types: [DamageType5E!]!
  condition: String
}

type Roll {
  faces: Int!
  count: Int!
  result: [Int!]
}

input RollInfoInput {
  faces: Int!
  count: Int!
}

input RollMessageAddInput {
  sourceId: ID
  dmRoll: Boolean!
  rolls: [RollInfoInput!]!
}

type RollMessageAddPayload {
  message: [Message!]
}

type RollMessageContent {
  dmRoll: Boolean!
  rolls: [Roll!]!
}

input RollMessagesAddInput {
  campaignId: ID!
  sceneId: ID
  messages: [RollMessageAddInput!]!
}

type RootQuery {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node

  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  campaigns(where: CampaignFilterInput): [Campaign!]!
  entries(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
    where: IEntryFilterInput
  ): EntriesConnection
  entry(id: ID): Npc5E
  enrollment(code: ID!, where: CampaignFilterInput): Campaign
}

type Scene implements Node {
  id: ID!
  campaignId: ID!
  stored: Boolean!
  description: String!
  name: String!
  entities: [MapEntity!]!
}

input SceneAddInput {
  campaignId: ID!
  name: String!
}

type SceneAddPayload {
  scene: Scene
}

input SceneDeleteInput {
  sceneId: ID!
}

type SceneDeletePayload {
  uUID: UUID
}

input SceneUpdateInput {
  sceneId: UUID!
  name: String!
  description: String!
}

type SceneUpdatePayload {
  scene: Scene
}

type Sense5E {
  description: String!
  range: Int!
}

input Sense5EInput {
  description: String!
  range: Int!
}

enum Size5E {
  TINY
  SMALL
  MEDIUM
  LARGE
  HUGE
  GARGANTUAN
}

enum Skill {
  ACROBATICS
  ANIMAL_HANDLING
  ARCANA
  ATHLETICS
  DECEPTION
  HISTORY
  INSIGHT
  INTIMIDATION
  INVESTIGATION
  MEDICINE
  NATURE
  PERCEPTION
  PERFORMANCE
  PERSUASION
  RELIGION
  SLEIGHT_OF_HAND
  STEALTH
  SURVIVAL
}

type Speed5E {
  walk: Int
  swim: Int
  fly: Int
}

input Speed5EInput {
  walk: Int
  swim: Int
  fly: Int
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  mapEntityChanged(sceneId: ID!): MapEntityChangeMessage!
}

input TextMessageAddInput {
  sourceId: ID
  content: String!
}

type TextMessageAddPayload {
  message: [Message!]
}

type TextMessageContent {
  text: String!
}

input TextMessagesAddInput {
  campaignId: ID!
  sceneId: ID
  messages: [TextMessageAddInput!]!
}

type User {
  userName: String
  email: String
}

input UserAddInput {
  userName: String!
  password: String!
  email: String!
}

type UserAddPayload {
  user: User
}

scalar UUID

