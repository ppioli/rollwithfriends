import {
  createAsyncThunk,
  createEntityAdapter,
  createSlice,
  PayloadAction,
  Update,
} from "@reduxjs/toolkit";

import { AppState } from "store";
import Token from "features/token/Token.model";

const testToken: Token = {
  id: 1,
  x: 10,
  y: 10,
  width: 30,
  height: 30,
};

const tokenAdapter = createEntityAdapter<Token>();

const initialState = tokenAdapter.getInitialState();

let currentId = 0;

// export const updateToken = createAsyncThunk(
//   "token/updateToken",
//   async (payload: Update<Token>, dispatch) => {
//     dispatch(addToken(payload.changes));
//     await new Promise<void>((resolve) => setTimeout(() => resolve(), 300));
//     // The value we return becomes the `fulfilled` action payload
//     return Promise.resolve(payload);
//   }
// );

export const updateToken = createAsyncThunk(
  "token/updateToken",
  async (payload: Update<Token>) => {
    await new Promise<void>((resolve) => setTimeout(() => resolve(), 300));
    // The value we return becomes the `fulfilled` action payload
    return Promise.resolve(payload);
  }
);

export const addToken = createAsyncThunk(
  "token/addToken",
  async (token: Omit<Token, "id">) => {
    await new Promise<void>((resolve) => setTimeout(() => resolve(), 300));
    // The value we return becomes the `fulfilled` action payload
    return Promise.resolve({ id: ++currentId, ...token });
  }
);

export const tokenSlice = createSlice({
  name: "token",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    removeToken: (
      state,
      { payload: { id } }: PayloadAction<{ id: number }>
    ) => {
      tokenAdapter.removeOne(state, id);
    },
    updateToken: (state, { payload }: PayloadAction<Update<Token>>) => {
      tokenAdapter.updateOne(state, payload);
    },
    // decrement: (state) => {
    //     state.value -= 1
    // },
    // // Use the PayloadAction type to declare the contents of `action.payload`
    // incrementByAmount: (state, action: PayloadAction<number>) => {
    //     state.value += action.payload
    // },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // .addCase(addTokenAsync.pending, (state) => {
      //   state.status = "loading";
      // })
      .addCase(addToken.fulfilled, tokenAdapter.addOne)
      .addCase(updateToken.fulfilled, tokenAdapter.updateOne);
  },
});

// Export the customized selectors for this adapter using `getSelectors`
export const {
  selectAll: selectAllTokens,
  selectById: selectTokenById,
  selectIds: selectTokenIds,
  // Pass in a selector that returns the posts slice of state
} = tokenAdapter.getSelectors((state: AppState) => state.token);

// export const selectPostsByUser = createSelector(
//     [selectAllPosts, (state, userId) => userId],
//     (posts, userId) => posts.filter(post => post.user === userId)
// )

export default tokenSlice.reducer;
