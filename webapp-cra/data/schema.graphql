schema {
  query: RootQuery
  mutation: Mutation
  subscription: Subscription
}

"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int! = 0

  """Streamed when true."""
  if: Boolean
) on FIELD

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

type Campaign implements Node {
  messages(
    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String
  ): MessagesConnection
  participants: [Participant!]!
  isDungeonMaster: Boolean!
  selectedScene(sceneId: ID): Scene
  id: ID!
  name: String!
  description: String!
  dungeonMasterId: String!
  scenes: [Scene!]!
  selectedSceneId: Int
}

input CampaignAddInput {
  name: String!
  description: String!
}

type CampaignAddPayload {
  campaign: Campaign
}

input CampaignFilterInput {
  and: [CampaignFilterInput!]
  or: [CampaignFilterInput!]
  id: IdOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  dungeonMasterId: StringOperationFilterInput
  scenes: ListFilterInputTypeOfSceneFilterInput
  selectedSceneId: ComparableNullableOfInt32OperationFilterInput
}

enum CampaignRoll {
  DUNGEON_MASTER
  PLAYER
}

enum ChangeMessageType {
  ADD
  UPDATE
  DELETE
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ComparableNullableOfInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input EnrollmentAddInput {
  code: ID!
}

type EnrollmentAddPayload {
  campaign: Campaign
}

type FileLoadingMessage {
  progress: Int!
}

input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}

enum ImageState {
  LOADED
  LOADING
  MISSING
}

input ListFilterInputTypeOfMapEntityFilterInput {
  all: MapEntityFilterInput
  none: MapEntityFilterInput
  some: MapEntityFilterInput
  any: Boolean
}

input ListFilterInputTypeOfSceneFilterInput {
  all: SceneFilterInput
  none: SceneFilterInput
  some: SceneFilterInput
  any: Boolean
}

input MapEntitiesAddInput {
  sceneId: ID!
  entities: [MapEntityAddInput!]!
}

input MapEntitiesUpdateInput {
  sceneId: ID!
  entities: [MapEntityUpdateInput!]!
}

type MapEntity implements Node {
  imageState: ImageState!
  id: ID!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  scene: Scene!
  sceneId: Int!
  imageId: Int!
}

input MapEntityAddInput {
  x: Int!
  y: Int!
  width: Int!
  height: Int!
  fileType: String!
}

type MapEntityAddPayload {
  mapEntity: [MapEntity!]
}

type MapEntityChangeMessage {
  type: ChangeMessageType!
  userId: String!
  payload: [MapEntity!]!
}

input MapEntityDeleteInput {
  sceneId: ID!
  deleted: [ID!]!
}

type MapEntityDeletePayload {
  mapEntity: [MapEntity!]
}

input MapEntityFilterInput {
  and: [MapEntityFilterInput!]
  or: [MapEntityFilterInput!]
  id: IdOperationFilterInput
  x: ComparableInt32OperationFilterInput
  y: ComparableInt32OperationFilterInput
  width: ComparableInt32OperationFilterInput
  height: ComparableInt32OperationFilterInput
  scene: SceneFilterInput
  sceneId: ComparableInt32OperationFilterInput
  imageId: ComparableInt32OperationFilterInput
}

input MapEntityUpdateInput {
  id: ID!
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

type MapEntityUpdatePayload {
  mapEntity: [MapEntity!]
}

type Message implements Node {
  content: MessageContent!
  id: ID!
  userId: String!
  campaign: Campaign!
  campaignId: Int!
  createdAt: DateTime!
  type: MessageType!
}

union MessageContent = TextMessageContent | RollMessageContent

type MessageEvent {
  messages: [Message!]!
}

"""A connection to a list of items."""
type MessagesConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessagesEdge!]

  """A flattened list of the nodes."""
  nodes: [Message!]
}

"""An edge in a connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Message!
}

enum MessageType {
  TEXT
  ROLL
}

type Mutation {
  campaignAdd(input: CampaignAddInput!): CampaignAddPayload!
  enrollmentAdd(input: EnrollmentAddInput!): EnrollmentAddPayload!
  mapEntityUpdate(input: MapEntitiesUpdateInput!): MapEntityUpdatePayload!
  mapEntityAdd(input: MapEntitiesAddInput!): MapEntityAddPayload!
  mapEntityDelete(input: MapEntityDeleteInput!): MapEntityDeletePayload!
  sceneAdd(input: SceneAddInput!): SceneAddPayload!
  sceneAddDelete(input: SceneAddDeleteInput!): SceneAddDeletePayload!
  sceneAddUpdate(input: SceneAddUpdateInput!): SceneAddUpdatePayload!
  textMessageAdd(input: TextMessagesAddInput!): TextMessageAddPayload!
  rollMessageAdd(input: RollMessagesAddInput!): RollMessageAddPayload!
}

"""
The node interface is implemented by entities that have a global unique identifier.
"""
interface Node {
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Participant implements Node {
  id: ID!
  userId: String!
  name: String!
  campaignRoll: CampaignRoll!
}

type Roll {
  faces: Int!
  count: Int!
  result: [Int!]
}

input RollInfoInput {
  faces: Int!
  count: Int!
}

input RollMessageAddInput {
  content: [RollInfoInput!]!
}

type RollMessageAddPayload {
  message: [Message!]
}

type RollMessageContent {
  rolls: [Roll!]!
}

input RollMessagesAddInput {
  campaignId: ID!
  messages: [RollMessageAddInput!]!
}

type RootQuery {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node

  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  campaigns(where: CampaignFilterInput): [Campaign!]!
  enrollment(code: ID!, where: CampaignFilterInput): Campaign
}

type Scene implements Node {
  id: ID!
  name: String!
  campaign: Campaign!
  campaignId: Int!
  entities: [MapEntity!]!
}

input SceneAddDeleteInput {
  sceneId: ID!
}

type SceneAddDeletePayload {
  scene: Scene
}

input SceneAddInput {
  campaignId: ID!
  name: String!
}

type SceneAddPayload {
  scene: Scene
}

input SceneAddUpdateInput {
  sceneId: ID!
  name: String!
}

type SceneAddUpdatePayload {
  scene: Scene
}

input SceneFilterInput {
  and: [SceneFilterInput!]
  or: [SceneFilterInput!]
  id: IdOperationFilterInput
  name: StringOperationFilterInput
  campaign: CampaignFilterInput
  campaignId: ComparableInt32OperationFilterInput
  entities: ListFilterInputTypeOfMapEntityFilterInput
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

type Subscription {
  mapEntityChanged(sceneId: ID!): MapEntityChangeMessage!
  fileLoadingSub(fileId: Int!): FileLoadingMessage!
  messageSub(campaignId: ID!): MessageEvent!
}

input TextMessageAddInput {
  content: String!
}

type TextMessageAddPayload {
  message: [Message!]
}

type TextMessageContent {
  text: String!
}

input TextMessagesAddInput {
  campaignId: ID!
  messages: [TextMessageAddInput!]!
}

